package cni

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/poruru/edge-serverless-box/services/agent/internal/config"
)

type Plugin struct {
	Type         string        `json:"type"`
	Bridge       string        `json:"bridge,omitempty"`
	IsGateway    bool          `json:"isGateway,omitempty"`
	IPMasq       bool          `json:"ipMasq,omitempty"`
	DNS          *DNSConfig    `json:"dns,omitempty"`
	IPAM         *IPAMConfig   `json:"ipam,omitempty"`
	Capabilities *Capabilities `json:"capabilities,omitempty"`
}

type DNSConfig struct {
	Nameservers []string `json:"nameservers,omitempty"`
}

type IPAMConfig struct {
	Type       string        `json:"type"`
	Subnet     string        `json:"subnet,omitempty"`
	RangeStart string        `json:"rangeStart,omitempty"`
	RangeEnd   string        `json:"rangeEnd,omitempty"`
	Routes     []RouteConfig `json:"routes,omitempty"`
}

type RouteConfig struct {
	Dst string `json:"dst"`
}

type Capabilities struct {
	PortMappings bool `json:"portMappings,omitempty"`
}

// Config represents the CNI configuration structure.
type Config struct {
	Comment    string   `json:"_comment,omitempty"`
	CNIVersion string   `json:"cniVersion"`
	Name       string   `json:"name"`
	Plugins    []Plugin `json:"plugins"`
}

// GenerateConfig generates a CNI configuration file based on the provided subnet.
// If subnet is empty, it uses the default configuration.
func GenerateConfig(configDir, subnet, networkName, bridgeName string) error {
	defaultSubnet := config.DefaultCNISubnet
	ipam := &IPAMConfig{
		Type:   "host-local",
		Subnet: defaultSubnet,
		Routes: []RouteConfig{{Dst: "0.0.0.0/0"}},
	}
	name := strings.TrimSpace(networkName)
	if name == "" {
		name = "esb-net"
	}
	bridge := strings.TrimSpace(bridgeName)
	if bridge == "" {
		bridge = "esb0"
	}

	if subnet != "" {
		cidr, err := parseIPv4CIDR(subnet)
		if err != nil {
			return fmt.Errorf("invalid subnet %q: %w", subnet, err)
		}
		rangeStart, rangeEnd, err := cidrHostRange(cidr)
		if err != nil {
			return fmt.Errorf("calculate host range for %s: %w", subnet, err)
		}
		// When a specific subnet is provided, we restrict the range
		ipam.Subnet = cidr.String()
		ipam.RangeStart = rangeStart.String()
		ipam.RangeEnd = rangeEnd.String()
	}

	dnsServer := resolveDNSServer()

	config := Config{
		Comment:    "Auto-generated by agent on startup",
		CNIVersion: "1.0.0",
		Name:       name,
		Plugins: []Plugin{
			{
				Type:      "bridge",
				Bridge:    bridge,
				IsGateway: true,
				IPMasq:    true,
				DNS: &DNSConfig{
					Nameservers: []string{dnsServer},
				},
				IPAM: ipam,
			},
			{
				Type: "portmap",
				Capabilities: &Capabilities{
					PortMappings: true,
				},
			},
		},
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return err
	}

	if err := os.MkdirAll(configDir, 0o755); err != nil {
		return err
	}

	filename := fmt.Sprintf("10-%s.conflist", name)
	path := filepath.Join(configDir, filename)
	return os.WriteFile(path, data, 0o644)
}

func resolveDNSServer() string {
	defaultServer := config.DefaultCNIDNSServer
	if value := strings.TrimSpace(os.Getenv("CNI_DNS_SERVER")); value != "" {
		return value
	}
	if value := strings.TrimSpace(os.Getenv("CNI_GW_IP")); value != "" {
		return value
	}
	return defaultServer
}

func parseIPv4CIDR(value string) (*net.IPNet, error) {
	_, cidr, err := net.ParseCIDR(strings.TrimSpace(value))
	if err != nil {
		return nil, err
	}
	if cidr == nil || cidr.IP.To4() == nil {
		return nil, fmt.Errorf("IPv4 CIDR required")
	}
	return cidr, nil
}

func cidrHostRange(cidr *net.IPNet) (net.IP, net.IP, error) {
	ones, bits := cidr.Mask.Size()
	if bits != 32 || cidr.IP.To4() == nil {
		return nil, nil, fmt.Errorf("IPv4 CIDR required")
	}
	if ones >= 31 {
		return nil, nil, fmt.Errorf("CIDR %s has no usable host range", cidr.String())
	}

	network := cidr.IP.Mask(cidr.Mask).To4()
	networkInt := binary.BigEndian.Uint32(network)
	maskInt := binary.BigEndian.Uint32(cidr.Mask)
	broadcastInt := networkInt | ^maskInt

	return uint32ToIPv4(networkInt + 1), uint32ToIPv4(broadcastInt - 1), nil
}

func uint32ToIPv4(value uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, value)
	return ip
}
