package cni

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/poruru-code/esb/services/agent/internal/config"
)

const DefaultIdentityFilePath = "/var/lib/cni/esb-cni.env"

type Plugin struct {
	Type         string        `json:"type"`
	Bridge       string        `json:"bridge,omitempty"`
	IsGateway    bool          `json:"isGateway,omitempty"`
	IPMasq       bool          `json:"ipMasq,omitempty"`
	DNS          *DNSConfig    `json:"dns,omitempty"`
	IPAM         *IPAMConfig   `json:"ipam,omitempty"`
	Capabilities *Capabilities `json:"capabilities,omitempty"`
}

type DNSConfig struct {
	Nameservers []string `json:"nameservers,omitempty"`
}

type IPAMConfig struct {
	Type       string        `json:"type"`
	Subnet     string        `json:"subnet,omitempty"`
	RangeStart string        `json:"rangeStart,omitempty"`
	RangeEnd   string        `json:"rangeEnd,omitempty"`
	Routes     []RouteConfig `json:"routes,omitempty"`
}

type RouteConfig struct {
	Dst string `json:"dst"`
}

type Capabilities struct {
	PortMappings bool `json:"portMappings,omitempty"`
}

// Config represents the CNI configuration structure.
type Config struct {
	Comment    string   `json:"_comment,omitempty"`
	CNIVersion string   `json:"cniVersion"`
	Name       string   `json:"name"`
	Plugins    []Plugin `json:"plugins"`
}

type probeIPAMConfig struct {
	Subnet string `json:"subnet,omitempty"`
}

type probePlugin struct {
	IPAM *probeIPAMConfig `json:"ipam,omitempty"`
}

type probeConfig struct {
	Name    string           `json:"name"`
	IPAM    *probeIPAMConfig `json:"ipam,omitempty"`
	Plugins []probePlugin    `json:"plugins,omitempty"`
}

// GenerateConfig generates a CNI configuration file based on the provided subnet.
// All network identity inputs must be resolved by the caller.
func GenerateConfig(configDir, subnet, networkName, bridgeName string) error {
	name := strings.TrimSpace(networkName)
	if name == "" {
		return fmt.Errorf("network name is required")
	}
	bridge := strings.TrimSpace(bridgeName)
	if bridge == "" {
		return fmt.Errorf("bridge name is required")
	}

	cidr, err := parseIPv4CIDR(subnet)
	if err != nil {
		return fmt.Errorf("invalid subnet %q: %w", subnet, err)
	}
	rangeStart, rangeEnd, err := cidrHostRange(cidr)
	if err != nil {
		return fmt.Errorf("calculate host range for %s: %w", subnet, err)
	}
	ipam := &IPAMConfig{
		Type:       "host-local",
		Subnet:     cidr.String(),
		RangeStart: rangeStart.String(),
		RangeEnd:   rangeEnd.String(),
		Routes:     []RouteConfig{{Dst: "0.0.0.0/0"}},
	}

	dnsServer := resolveDNSServer(ipam.Subnet)

	config := Config{
		Comment:    "Auto-generated by agent on startup",
		CNIVersion: "1.0.0",
		Name:       name,
		Plugins: []Plugin{
			{
				Type:      "bridge",
				Bridge:    bridge,
				IsGateway: true,
				IPMasq:    true,
				DNS: &DNSConfig{
					Nameservers: []string{dnsServer},
				},
				IPAM: ipam,
			},
			{
				Type: "portmap",
				Capabilities: &Capabilities{
					PortMappings: true,
				},
			},
		},
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return err
	}

	if err := os.MkdirAll(configDir, 0o755); err != nil {
		return err
	}

	filename := fmt.Sprintf("10-%s.conflist", name)
	path := filepath.Join(configDir, filename)
	return os.WriteFile(path, data, 0o644)
}

func resolveDNSServer(subnet string) string {
	defaultServer := config.DefaultCNIDNSServer
	if value := strings.TrimSpace(os.Getenv("CNI_DNS_SERVER")); value != "" {
		return value
	}
	if value := strings.TrimSpace(os.Getenv("CNI_GW_IP")); value != "" {
		return value
	}
	if gw, err := GatewayIPFromSubnet(subnet); err == nil {
		return gw
	}
	return defaultServer
}

func GatewayIPFromSubnet(subnet string) (string, error) {
	cidr, err := parseIPv4CIDR(subnet)
	if err != nil {
		return "", err
	}
	first, _, err := cidrHostRange(cidr)
	if err != nil {
		return "", err
	}
	return first.String(), nil
}

func WriteIdentityFile(path, networkName, bridgeName, subnet string) error {
	outputPath := strings.TrimSpace(path)
	if outputPath == "" {
		outputPath = DefaultIdentityFilePath
	}

	name := strings.TrimSpace(networkName)
	bridge := strings.TrimSpace(bridgeName)
	cidr := strings.TrimSpace(subnet)
	if name == "" || bridge == "" || cidr == "" {
		return fmt.Errorf(
			"identity requires non-empty network/bridge/subnet (network=%q bridge=%q subnet=%q)",
			name,
			bridge,
			cidr,
		)
	}

	lines := []string{
		fmt.Sprintf("CNI_NETWORK=%s", name),
		fmt.Sprintf("CNI_BRIDGE=%s", bridge),
		fmt.Sprintf("CNI_SUBNET=%s", cidr),
	}
	if gw, err := GatewayIPFromSubnet(cidr); err == nil {
		lines = append(lines, fmt.Sprintf("CNI_GW_IP=%s", gw))
	}

	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}

	tmp, err := os.CreateTemp(dir, ".esb-cni-identity-*.tmp")
	if err != nil {
		return err
	}
	tmpName := tmp.Name()
	defer func() {
		_ = os.Remove(tmpName)
	}()

	payload := strings.Join(lines, "\n") + "\n"
	if _, err := tmp.WriteString(payload); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Chmod(0o644); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Close(); err != nil {
		return err
	}
	return os.Rename(tmpName, outputPath)
}

func CollectSubnetClaims(configDir, selfNetwork string) (map[string]string, error) {
	claims := map[string]string{}
	entries, err := os.ReadDir(configDir)
	if err != nil {
		if os.IsNotExist(err) {
			return claims, nil
		}
		return nil, err
	}

	normalizedSelf := strings.TrimSpace(selfNetwork)
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		ext := strings.ToLower(filepath.Ext(entry.Name()))
		if ext != ".conflist" && ext != ".conf" {
			continue
		}

		path := filepath.Join(configDir, entry.Name())
		data, err := os.ReadFile(path)
		if err != nil {
			return nil, err
		}

		var cfg probeConfig
		if err := json.Unmarshal(data, &cfg); err != nil {
			continue
		}
		networkName := strings.TrimSpace(cfg.Name)
		if networkName == "" || networkName == normalizedSelf {
			continue
		}

		if subnet, ok := firstValidSubnet(cfg); ok {
			claims[subnet] = networkName
		}
	}
	return claims, nil
}

func parseIPv4CIDR(value string) (*net.IPNet, error) {
	_, cidr, err := net.ParseCIDR(strings.TrimSpace(value))
	if err != nil {
		return nil, err
	}
	if cidr == nil || cidr.IP.To4() == nil {
		return nil, fmt.Errorf("IPv4 CIDR required")
	}
	return cidr, nil
}

func firstValidSubnet(cfg probeConfig) (string, bool) {
	if cfg.IPAM != nil {
		if subnet := normalizeSubnet(cfg.IPAM.Subnet); subnet != "" {
			return subnet, true
		}
	}
	for _, plugin := range cfg.Plugins {
		if plugin.IPAM == nil {
			continue
		}
		if subnet := normalizeSubnet(plugin.IPAM.Subnet); subnet != "" {
			return subnet, true
		}
	}
	return "", false
}

func normalizeSubnet(value string) string {
	cidr, err := parseIPv4CIDR(value)
	if err != nil {
		return ""
	}
	return cidr.String()
}

func cidrHostRange(cidr *net.IPNet) (net.IP, net.IP, error) {
	ones, bits := cidr.Mask.Size()
	if bits != 32 || cidr.IP.To4() == nil {
		return nil, nil, fmt.Errorf("IPv4 CIDR required")
	}
	if ones >= 31 {
		return nil, nil, fmt.Errorf("CIDR %s has no usable host range", cidr.String())
	}

	network := cidr.IP.Mask(cidr.Mask).To4()
	networkInt := binary.BigEndian.Uint32(network)
	maskInt := binary.BigEndian.Uint32(cidr.Mask)
	broadcastInt := networkInt | ^maskInt

	return uint32ToIPv4(networkInt + 1), uint32ToIPv4(broadcastInt - 1), nil
}

func uint32ToIPv4(value uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, value)
	return ip
}
