「Phase 1: Compute & Network (Routing Automation)」を実装するためのコードセットです。
以下の4つのファイルを更新・作成することで、`template.yaml` の `Events` (API Gateway) 定義から `routing.yml` を自動生成できるようになります。

### 1. `tools/generator/parser.py` (更新)

`AWS::Serverless::Function` の `Events` プロパティを解析するロジックを追加します。

```python
"""
SAM Template Parser

SAMテンプレート(YAML)をパースし、Lambda関数の情報を抽出します。
CloudFormation intrinsic functions (!Sub, !Ref等) を安全に処理します。
"""

import yaml
from typing import Any
import re


class CfnLoader(yaml.SafeLoader):
    """CloudFormation intrinsic functionsを処理するYAMLローダー"""
    pass


def cfn_constructor(loader: yaml.Loader, node: yaml.Node) -> Any:
    """CloudFormation タグ用のコンストラクタ"""
    if isinstance(node, yaml.ScalarNode):
        return loader.construct_scalar(node)
    elif isinstance(node, yaml.SequenceNode):
        return loader.construct_sequence(node)
    elif isinstance(node, yaml.MappingNode):
        return loader.construct_mapping(node)
    return ""


# CloudFormation タグを登録
for tag in ["!Ref", "!Sub", "!GetAtt", "!ImportValue", "!If", "!Join", "!Select", "!Split"]:
    yaml.add_constructor(tag, cfn_constructor, Loader=CfnLoader)


def parse_sam_template(content: str, parameters: dict | None = None) -> dict:
    """
    SAMテンプレート文字列をパースし、Lambda関数のリストを返す
    """
    if parameters is None:
        parameters = {}

    data = yaml.load(content, Loader=CfnLoader)

    # Globalsからデフォルト値を取得
    globals_config = data.get("Globals", {}).get("Function", {})
    default_runtime = globals_config.get("Runtime", "python3.12")
    default_handler = globals_config.get("Handler", "lambda_function.lambda_handler")
    default_timeout = globals_config.get("Timeout", 30)
    default_memory = globals_config.get("MemorySize", 128)

    functions = []
    resources = data.get("Resources", {})

    for logical_id, resource in resources.items():
        resource_type = resource.get("Type", "")

        # AWS::Serverless::Function のみ対象
        if resource_type != "AWS::Serverless::Function":
            continue

        props = resource.get("Properties", {})

        # 関数名を取得（!Sub等を解決）
        function_name = props.get("FunctionName", logical_id)
        function_name = _resolve_intrinsic(function_name, parameters)

        # コードURI
        code_uri = props.get("CodeUri", "./")
        if not code_uri.endswith("/"):
            code_uri += "/"

        # ハンドラ
        handler = props.get("Handler", default_handler)

        # ランタイム
        runtime = props.get("Runtime", default_runtime)

        # 環境変数
        env_vars = props.get("Environment", {}).get("Variables", {})
        resolved_env = {}
        for key, value in env_vars.items():
            resolved_env[key] = _resolve_intrinsic(value, parameters)

        # --- Phase 1: Events (API Gateway) 解析追加 ---
        events = props.get("Events", {})
        api_routes = []
        for event_name, event_props in events.items():
            # Type: Api (API Gateway) のみを抽出
            if event_props.get("Type") == "Api":
                evt_properties = event_props.get("Properties", {})
                path = evt_properties.get("Path")
                method = evt_properties.get("Method")
                
                if path and method:
                    api_routes.append({
                        "path": path,
                        "method": method
                    })
        # ---------------------------------------------

        functions.append(
            {
                "logical_id": logical_id,
                "name": function_name,
                "code_uri": code_uri,
                "handler": handler,
                "runtime": runtime,
                "timeout": props.get("Timeout", default_timeout),
                "memory_size": props.get("MemorySize", default_memory),
                "environment": resolved_env,
                "events": api_routes,  # 追加
            }
        )

    return {"functions": functions}


def _resolve_intrinsic(value: Any, parameters: dict) -> str:
    """
    CloudFormation intrinsic functionを解決する
    簡易実装: !Sub ${Param} 形式のみ対応
    """
    if not isinstance(value, str):
        return str(value) if value is not None else ""

    def replace_param(match):
        param_name = match.group(1)
        return parameters.get(param_name, f"${{{param_name}}}")

    return re.sub(r"\$\{(\w+)\}", replace_param, value)

```

### 2. `tools/generator/templates/routing.yml.j2` (新規作成)

Jinja2テンプレートファイルを作成します。

```yaml
# Auto-generated by SAM Template Generator
# DO NOT EDIT MANUALLY - Regenerate with: python -m tools.generator.main

routes:
{% for func in functions %}
  {% for event in func.events %}
  - path: "{{ event.path }}"
    method: "{{ event.method | upper }}"
    function: "{{ func.name }}"
  {% endfor %}
{% endfor %}

```

### 3. `tools/generator/renderer.py` (更新)

`render_routing_yml` 関数を追加します。

```python
"""
Dockerfile, functions.yml, and routing.yml Renderer
"""

from pathlib import Path
from jinja2 import Environment, FileSystemLoader

TEMPLATE_DIR = Path(__file__).parent / "templates"


def render_dockerfile(
    func_config: dict,
    docker_config: dict,
) -> str:
    """Dockerfileをレンダリングする"""
    env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
    template = env.get_template("Dockerfile.j2")

    runtime = func_config.get("runtime", "python3.12")
    python_version = runtime.replace("python", "")

    context = {
        "python_version": python_version,
        "sitecustomize_source": docker_config.get(
            "sitecustomize_source", "runtime/sitecustomize.py"
        ),
        "code_uri": func_config.get("code_uri", "./"),
        "handler": func_config.get("handler", "lambda_function.lambda_handler"),
        "has_requirements": func_config.get("has_requirements", False),
    }

    return template.render(context)


def render_functions_yml(
    functions: list[dict],
) -> str:
    """functions.yml をレンダリングする"""
    env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
    template = env.get_template("functions.yml.j2")

    return template.render(functions=functions)


def render_routing_yml(
    functions: list[dict],
) -> str:
    """
    routing.yml をレンダリングする (Phase 1 追加)
    
    Args:
        functions: 関数リスト（eventsリストを含む）
    """
    env = Environment(loader=FileSystemLoader(TEMPLATE_DIR))
    template = env.get_template("routing.yml.j2")

    return template.render(functions=functions)

```

### 4. `tools/generator/main.py` (更新)

メインフローに `routing.yml` 生成処理を組み込みます。

```python
#!/usr/bin/env python3
"""
SAM Template Generator

SAMテンプレートからローカル実行用の以下のファイルを生成します:
- Dockerfile
- functions.yml (Lambda定義)
- routing.yml (API Gatewayルーティング) [New]
"""

import argparse
import sys
from pathlib import Path

import yaml

from .parser import parse_sam_template
from .renderer import render_dockerfile, render_functions_yml, render_routing_yml


def load_config(config_path: Path) -> dict:
    """設定ファイルをロード"""
    if not config_path.exists():
        return {}

    with open(config_path, encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def generate_files(
    config: dict,
    project_root: Path | None = None,
    dry_run: bool = False,
    verbose: bool = False,
) -> None:
    """SAMテンプレートからファイルを生成"""
    if project_root is None:
        project_root = Path.cwd()

    paths = config.get("paths", {})
    docker_config = config.get("docker", {})
    if "sitecustomize_source" not in docker_config:
        docker_config["sitecustomize_source"] = "tools/generator/runtime/sitecustomize.py"

    # SAMテンプレート読み込み
    sam_template_path = project_root / paths.get("sam_template", "template.yaml")
    if not sam_template_path.exists():
        raise FileNotFoundError(f"SAM template not found: {sam_template_path}")

    if verbose:
        print(f"Loading SAM template: {sam_template_path}")

    with open(sam_template_path, encoding="utf-8") as f:
        sam_content = f.read()

    # パース
    parameters = config.get("parameters", {})
    parsed = parse_sam_template(sam_content, parameters)
    functions = parsed["functions"]

    if verbose:
        print(f"Found {len(functions)} function(s)")

    # 1. 各関数のDockerfile生成
    for func in functions:
        code_uri = func["code_uri"]
        func_dir = project_root / code_uri
        dockerfile_path = func_dir / "Dockerfile"
        
        # requirements.txt チェック
        requirements_path = func_dir / "requirements.txt"
        func["has_requirements"] = requirements_path.exists()

        dockerfile_content = render_dockerfile(func, docker_config)

        if dry_run:
            print(f"\n=== {dockerfile_path} ===")
            print(dockerfile_content)
        else:
            if verbose:
                print(f"Generating: {dockerfile_path}")
            func_dir.mkdir(parents=True, exist_ok=True)
            with open(dockerfile_path, "w", encoding="utf-8") as f:
                f.write(dockerfile_content)

    # 2. functions.yml 生成
    functions_yml_path = project_root / paths.get("functions_yml", "config/functions.yml")
    functions_yml_content = render_functions_yml(functions)

    if dry_run:
        print(f"\n=== {functions_yml_path} ===")
        print(functions_yml_content)
    else:
        if verbose:
            print(f"Generating: {functions_yml_path}")
        functions_yml_path.parent.mkdir(parents=True, exist_ok=True)
        with open(functions_yml_path, "w", encoding="utf-8") as f:
            f.write(functions_yml_content)

    # 3. routing.yml 生成 (Phase 1)
    routing_yml_path = project_root / paths.get("routing_yml", "config/routing.yml")
    routing_yml_content = render_routing_yml(functions)

    if dry_run:
        print(f"\n=== {routing_yml_path} ===")
        print(routing_yml_content)
    else:
        if verbose:
            print(f"Generating: {routing_yml_path}")
        routing_yml_path.parent.mkdir(parents=True, exist_ok=True)
        with open(routing_yml_path, "w", encoding="utf-8") as f:
            f.write(routing_yml_content)

    if not dry_run:
        print(f"Generated Dockerfiles, functions.yml, and routing.yml")


def main():
    parser = argparse.ArgumentParser(description="Generate local Docker files from SAM template")
    parser.add_argument("--config", default="tools/generator/generator.yml", help="Generator config path")
    parser.add_argument("--template", help="SAM template path (overrides config)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be generated without writing files")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    args = parser.parse_args()
    config_path = Path(args.config)
    config = load_config(config_path)

    if args.template:
        if "paths" not in config:
            config["paths"] = {}
        config["paths"]["sam_template"] = args.template

    try:
        generate_files(config, dry_run=args.dry_run, verbose=args.verbose)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()

```