"""
Where: services/gateway/routes.py
What: Gateway endpoint handlers and route registration helpers.
Why: Separate request handling concerns from app initialization logic.
"""

import asyncio
import logging
from dataclasses import asdict
from datetime import datetime, timezone
from typing import Optional

from fastapi import BackgroundTasks, FastAPI, Header, HTTPException, Request
from fastapi.responses import JSONResponse, Response

from .api.deps import (
    FunctionRegistryDep,
    InputContextDep,
    LambdaInvokerDep,
    PoolManagerDep,
    ProcessorDep,
    RouteMatcherDep,
    UserIdDep,
)
from .config import GatewayConfig, config
from .core.exceptions import ContainerStartError, LambdaExecutionError
from .core.security import create_access_token
from .core.utils import parse_lambda_response
from .models import AuthenticationResult, AuthRequest, AuthResponse

logger = logging.getLogger("gateway.main")

CORS_ALLOW_METHODS = "GET,POST,PUT,DELETE,PATCH,HEAD,OPTIONS"
CORS_ALLOW_HEADERS_DEFAULT = (
    "Authorization,Content-Type,X-Amz-Date,X-Api-Key,"
    "X-Amz-Security-Token,X-Amz-Invocation-Type,X-Amzn-Trace-Id"
)
CORS_MAX_AGE_SECONDS = "3600"
USER_AUTHORIZED_HEADER = "PADMA_USER_AUTHORIZED"
UNSAFE_PROXY_HEADERS = {"content-length", "transfer-encoding", "connection", "keep-alive"}


def build_cors_headers(request: Request) -> dict[str, str]:
    origin = request.headers.get("origin")
    request_headers = request.headers.get("access-control-request-headers")

    headers = {
        "Access-Control-Allow-Origin": origin or "*",
        "Access-Control-Allow-Methods": CORS_ALLOW_METHODS,
        "Access-Control-Allow-Headers": request_headers or CORS_ALLOW_HEADERS_DEFAULT,
        "Access-Control-Max-Age": CORS_MAX_AGE_SECONDS,
    }

    if origin:
        headers["Vary"] = "Origin"

    return headers


def sanitize_proxy_headers(
    headers: dict[str, str], multi_headers: dict[str, list[str]]
) -> tuple[dict[str, str], dict[str, list[str]]]:
    """Drop transport-level headers that must be regenerated by ASGI server."""
    clean_headers = {k: v for k, v in headers.items() if k.lower() not in UNSAFE_PROXY_HEADERS}
    clean_multi_headers = {
        k: v for k, v in multi_headers.items() if k.lower() not in UNSAFE_PROXY_HEADERS
    }
    return clean_headers, clean_multi_headers


async def authenticate_user(
    request: AuthRequest, response: Response, x_api_key: Optional[str] = Header(None)
):
    """User authentication endpoint."""
    if not x_api_key or x_api_key != config.X_API_KEY:
        logger.warning("Auth failed. Invalid API Key received.")
        raise HTTPException(status_code=401, detail="Unauthorized")

    response.headers[USER_AUTHORIZED_HEADER] = "true"

    username = request.AuthParameters.USERNAME
    password = request.AuthParameters.PASSWORD

    if username == config.AUTH_USER and password == config.AUTH_PASS:
        id_token = create_access_token(
            username=username,
            secret_key=config.JWT_SECRET_KEY,
            expires_delta=config.JWT_EXPIRES_DELTA,
        )
        return AuthResponse(AuthenticationResult=AuthenticationResult(IdToken=id_token))

    return JSONResponse(
        status_code=401,
        content={"message": "Unauthorized"},
        headers={USER_AUTHORIZED_HEADER: "true"},
    )


async def health_check():
    """Health check implementation."""
    return {"status": "healthy", "timestamp": datetime.now(timezone.utc).isoformat()}


async def list_container_metrics(user_id: UserIdDep, pool_manager: PoolManagerDep):
    """Agent からコンテナメトリクスを取得"""
    containers = await pool_manager.provision_client.list_containers()
    if not containers:
        return {"containers": []}

    tasks = [pool_manager.provision_client.get_container_metrics(c.id) for c in containers]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    metrics_list = []
    failures = 0
    not_implemented_errors = 0

    for container, result in zip(containers, results, strict=True):
        if isinstance(result, Exception):
            err_msg = str(result)
            logger.error(f"Failed to fetch metrics for container {container.id}: {err_msg}")

            if "metrics not implemented" in err_msg.lower():
                not_implemented_errors += 1

            failures += 1
            metrics_list.append(
                {
                    "container_id": container.id,
                    "container_name": container.name,
                    "error": err_msg,
                }
            )
            continue
        metrics_list.append(asdict(result))

    if failures == len(containers):
        if not_implemented_errors > 0:
            raise HTTPException(
                status_code=501,
                detail=(
                    "Container metrics are not implemented for the current runtime (e.g. Docker)"
                ),
            )

        raise HTTPException(
            status_code=503,
            detail="Container metrics are unavailable from Agent runtime",
        )

    return {"containers": metrics_list, "failures": failures}


async def list_pool_metrics(user_id: UserIdDep, pool_manager: PoolManagerDep):
    """Gateway のプール統計を返す (runtime 非依存)."""
    return {
        "pools": await pool_manager.get_pool_stats(),
        "collected_at": datetime.now(timezone.utc).isoformat(),
    }


async def invoke_lambda_api(
    function_name: str,
    request: Request,
    background_tasks: BackgroundTasks,
    invoker: LambdaInvokerDep,
    registry: FunctionRegistryDep,
):
    """
    AWS Lambda Invoke API compatible endpoint.
    Handles requests from boto3.client('lambda').invoke().

    InvocationType:
      - RequestResponse (default): synchronous, return result
      - Event: asynchronous, return 202 immediately
    """
    if registry.get_function_config(function_name) is None:
        return JSONResponse(
            status_code=404,
            content={"message": f"Function not found: {function_name}"},
        )

    invocation_type = request.headers.get("X-Amz-Invocation-Type", "RequestResponse")
    body = await request.body()

    try:
        if invocation_type == "Event":
            background_tasks.add_task(  # ty: ignore[invalid-argument-type]  # FastAPI BackgroundTasks type stubs
                invoker.invoke_function,
                function_name,
                body,
                timeout=config.LAMBDA_INVOKE_TIMEOUT,
            )
            return Response(status_code=202, content=b"", media_type="application/json")

        result = await invoker.invoke_function(
            function_name, body, timeout=config.LAMBDA_INVOKE_TIMEOUT
        )

        if not result.success:
            return JSONResponse(status_code=result.status_code, content={"message": result.error})

        return Response(
            content=result.payload,
            status_code=result.status_code,
            headers=result.headers,
            media_type="application/json",
        )
    except ContainerStartError as exc:
        return JSONResponse(status_code=503, content={"message": str(exc)})
    except LambdaExecutionError as exc:
        return JSONResponse(status_code=502, content={"message": str(exc)})


async def cors_preflight(request: Request):
    return Response(status_code=204, headers=build_cors_headers(request))


async def gateway_handler(
    context: InputContextDep,
    processor: ProcessorDep,
):
    """Catch-all route: process request via GatewayRequestProcessor."""
    result = await processor.process_request(context)
    if not result.success:
        return JSONResponse(status_code=result.status_code, content={"message": result.error})

    parsed = parse_lambda_response(result)
    status_code = parsed.get("status_code", 200)
    headers = parsed.get("headers") or {}
    multi_headers = parsed.get("multi_headers") or {}
    headers, multi_headers = sanitize_proxy_headers(headers, multi_headers)

    if context.method == "HEAD":
        response = Response(status_code=status_code, content=b"", headers=headers)
    else:
        raw_content = parsed.get("raw_content")
        content = parsed.get("content")
        if raw_content is not None:
            response = Response(status_code=status_code, content=raw_content, headers=headers)
        elif isinstance(content, (dict, list)):
            response = JSONResponse(status_code=status_code, content=content, headers=headers)
        elif content is None:
            response = Response(status_code=status_code, content=b"", headers=headers)
        else:
            response = Response(status_code=status_code, content=str(content), headers=headers)

    for key, values in multi_headers.items():
        for value in values:
            response.headers.append(key, value)

    return response


async def list_functions(user_id: UserIdDep, registry: FunctionRegistryDep):
    """List all registered functions."""
    return {
        "functions": registry.list_functions(),
        "count": len(registry.list_functions()),
    }


async def list_routes(user_id: UserIdDep, matcher: RouteMatcherDep):
    """List all registered routes."""
    return {
        "routes": matcher.list_routes(),
        "count": matcher.get_route_count(),
    }


def register_routes(app: FastAPI, gateway_config: GatewayConfig) -> None:
    app.post(gateway_config.AUTH_ENDPOINT_PATH, response_model=AuthResponse)(authenticate_user)
    app.get("/metrics/containers", include_in_schema=False)(list_container_metrics)
    app.get("/metrics/pools", include_in_schema=False)(list_pool_metrics)
    app.post("/2015-03-31/functions/{function_name}/invocations")(invoke_lambda_api)
    app.options("/{path:path}", include_in_schema=False)(cors_preflight)
    app.api_route(
        "/{path:path}",
        methods=["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"],
        include_in_schema=False,
    )(gateway_handler)
    app.get("/functions", include_in_schema=False)(list_functions)
    app.get("/routes", include_in_schema=False)(list_routes)
