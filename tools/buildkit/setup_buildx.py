#!/usr/bin/env python3
# Where: tools/buildkit/setup_buildx.py
# What: Set up buildkitd config and a shared buildx builder.
# Why: Ensure BuildKit uses proxy settings in docker-container mode.
from __future__ import annotations

import json
import os
import re
import subprocess
import sys
from pathlib import Path

MARKER = "# Auto-generated by esb buildx setup."


def _read_defaults_env() -> dict[str, str]:
    defaults_path = Path(__file__).resolve().parents[2] / "config" / "defaults.env"
    if not defaults_path.exists():
        return {}
    values: dict[str, str] = {}
    for line in defaults_path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, _, value = line.partition("=")
        values[key.strip()] = value.strip()
    return values


def _normalize_slug(value: str) -> str:
    cleaned = re.sub(r"[^a-z0-9]+", "-", value.strip().lower()).strip("-")
    return cleaned or "esb"


def _resolve_slug() -> str:
    if value := os.environ.get("CLI_CMD"):
        return _normalize_slug(value)
    defaults = _read_defaults_env()
    if value := defaults.get("CLI_CMD"):
        return _normalize_slug(value)
    return "esb"


def _resolve_repo_root() -> Path:
    repo_root = Path(__file__).resolve().parents[2]
    markers = [
        repo_root / "docker-compose.docker.yml",
        repo_root / "docker-compose.containerd.yml",
    ]
    if not any(marker.exists() for marker in markers):
        raise RuntimeError(f"Failed to locate repo root from {repo_root}")
    return repo_root


def _resolve_buildkitd_path(repo_root: Path, slug: str) -> Path:
    override = os.environ.get("BUILDKITD_CONFIG", "").strip()
    if override:
        return Path(override).expanduser()
    return repo_root / f".{slug}" / "buildkitd.toml"


def _read_env_proxy() -> dict[str, str]:
    def pick(upper: str, lower: str) -> str:
        return os.environ.get(upper, "").strip() or os.environ.get(lower, "").strip()

    return {
        "httpProxy": pick("HTTP_PROXY", "http_proxy"),
        "httpsProxy": pick("HTTPS_PROXY", "https_proxy"),
        "noProxy": pick("NO_PROXY", "no_proxy"),
    }


def _read_docker_config_proxy() -> dict[str, str]:
    config_dir = Path(os.environ.get("DOCKER_CONFIG", Path.home() / ".docker")).expanduser()
    config_path = config_dir / "config.json"
    if not config_path.exists():
        return {}
    try:
        data = json.loads(config_path.read_text())
    except json.JSONDecodeError:
        return {}
    proxies = data.get("proxies") or {}
    defaults = proxies.get("default") or {}
    return {
        "httpProxy": str(defaults.get("httpProxy") or "").strip(),
        "httpsProxy": str(defaults.get("httpsProxy") or "").strip(),
        "noProxy": str(defaults.get("noProxy") or "").strip(),
    }


def _resolve_proxy() -> dict[str, str]:
    env_proxy = _read_env_proxy()
    docker_proxy = _read_docker_config_proxy()
    merged = {}
    for key in ("httpProxy", "httpsProxy", "noProxy"):
        value = env_proxy.get(key, "")
        if not value:
            value = docker_proxy.get(key, "")
        merged[key] = value
    return merged


def _build_driver_proxy_opts(proxy: dict[str, str]) -> list[str]:
    if not any(proxy.values()):
        return []
    entries: list[str] = []
    mapping = {
        "httpProxy": ("http_proxy", "HTTP_PROXY"),
        "httpsProxy": ("https_proxy", "HTTPS_PROXY"),
        "noProxy": ("no_proxy", "NO_PROXY"),
    }
    for key, env_keys in mapping.items():
        value = proxy.get(key, "").strip()
        if not value:
            continue
        if key == "noProxy" and "," in value:
            continue
        for env_key in env_keys:
            entries.append(f"env.{env_key}={value}")
    return entries


def _toml_quote(value: str) -> str:
    return json.dumps(value)


def _build_config_text(proxy: dict[str, str]) -> str:
    lines = [
        MARKER,
        "# Where: <repo_root>/.<brand>/buildkitd.toml",
        "# What: BuildKit daemon config for the ESB buildx builder.",
        "# Why: Provide proxy settings when BuildKit runs in a container.",
        "",
    ]
    if any(proxy.values()):
        lines.append("[proxy]")
        for key in ("httpProxy", "httpsProxy", "noProxy"):
            if value := proxy.get(key):
                lines.append(f"  {key} = {_toml_quote(value)}")
        lines.append("")
    return "\n".join(lines).rstrip() + "\n"


def _write_config(path: Path, content: str) -> bool:
    path.parent.mkdir(parents=True, exist_ok=True)
    if path.exists():
        existing = path.read_text()
        overwrite_flag = os.environ.get("BUILDKITD_OVERWRITE", "").strip()
        if MARKER not in existing and overwrite_flag != "1":
            print(
                f"[buildx] buildkitd.toml exists and is unmanaged: {path}.",
                file=sys.stderr,
            )
            print("[buildx] Set BUILDKITD_OVERWRITE=1 to overwrite.", file=sys.stderr)
            return False
    path.write_text(content)
    return True


def _run(cmd: list[str]) -> subprocess.CompletedProcess:
    return subprocess.run(cmd, capture_output=True, text=True)


def _list_builders() -> list[str]:
    result = _run(["docker", "buildx", "ls"])
    if result.returncode != 0:
        return []
    names: list[str] = []
    for raw in result.stdout.splitlines():
        if not raw or raw.startswith("NAME/") or raw[:1].isspace():
            continue
        parts = raw.split()
        if not parts:
            continue
        name = parts[0].rstrip("*")
        if name:
            names.append(name)
    return names


def _builder_exists(name: str) -> bool:
    return _run(["docker", "buildx", "inspect", "--builder", name]).returncode == 0


def _use_builder(name: str) -> None:
    _run(["docker", "buildx", "use", name])


def _remove_builder(name: str) -> None:
    _run(["docker", "buildx", "rm", name])


def _create_builder(
    name: str,
    config_path: Path | None,
    network_mode: str | None,
    proxy_env: list[str],
) -> None:
    cmd = [
        "docker",
        "buildx",
        "create",
        "--name",
        name,
        "--driver",
        "docker-container",
        "--use",
        "--bootstrap",
    ]
    if network_mode:
        cmd.extend(["--driver-opt", f"network={network_mode}"])
    for entry in proxy_env:
        cmd.extend(["--driver-opt", entry])
    if config_path:
        cmd.extend(["--buildkitd-config", str(config_path)])
    result = _run(cmd)
    if result.returncode != 0:
        print(result.stdout, file=sys.stderr)
        print(result.stderr, file=sys.stderr)
        result.check_returncode()


def main() -> int:
    slug = _resolve_slug()
    builder_name = f"{slug}-buildx"
    repo_root = _resolve_repo_root()
    config_path = _resolve_buildkitd_path(repo_root, slug)
    proxy = _resolve_proxy()
    content = _build_config_text(proxy)
    _write_config(config_path, content)
    proxy_env = _build_driver_proxy_opts(proxy)

    network_mode = os.environ.get("BUILDX_NETWORK_MODE", "host").strip() or None
    config_to_use = config_path if config_path.exists() else None
    for name in _list_builders():
        if name == builder_name or name.startswith(f"{builder_name}-"):
            _remove_builder(name)

    _create_builder(builder_name, config_to_use, network_mode, proxy_env)
    print(f"[buildx] builder ready: {builder_name}")
    if config_to_use:
        print(f"[buildx] using config: {config_to_use}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
